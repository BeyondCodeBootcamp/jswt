#!/usr/bin/env node
"use strict";

//require("dotenv").config({ path: ".env" });
//require("dotenv").config({ path: ".env.secret" });

var Fs = require("node:fs/promises");
var Path = require("node:path");
var Walk = require("./_walk.js");

var LOADABLE = [".js", ".cjs", ".mjs"];

// TODO make configurable
var IGNORABLE = [
  "index.js",
  "types.js",
  "build",
  "dist",
  "node_modules",
  "tmp",
];
var IGNORABLE_PATTERNS = /\.min\./;
var IGNORABLE_TYPES = [".bak", ".git", ".tmp"];

/**
 * @typedef Typedef
 * @prop {String} name - the name of the export
 * @prop {String} path - the importable path
 */

async function main() {
  /** @type Array<Typedef> */
  let typedefs = [];

  await Walk.walk(".", async function (err, pathname, dirent) {
    if (err) {
      // TODO check error
      console.error("unexpected walk error:");
      console.error(err);
      return false;
    }
    if (!dirent) {
      return false;
    }

    let read = await shouldRead(err, pathname, dirent);
    if (!read) {
      return read;
    }

    let js = await Fs.readFile(pathname, "utf8");
    let lines = js.split("\n");

    let _typedefs = lines
      .filter(function (line) {
        // \x20 for space so that this match doesn't find its own file
        return line.includes("* @typedef\x20") && !line.includes("{import(");
      })
      .map(function (line) {
        let parts = line.trim().replace(/\s+/g, " ").split(" ");
        let name = parts.pop();
        if ("*/" === name) {
          name = parts.pop();
        }

        return {
          path: `./${pathname}`,
          name: name,
        };
      });
    //@ts-ignore - apparently `concat()` is `any` rather than `T`
    typedefs = typedefs.concat(_typedefs);
  });

  let defLines = typedefs.map(function (t) {
    return ` * @typedef {import('${t.path}').${t.name}} ${t.name}`;
  });

  let typeLines;
  let indexLines;

  let global = process.argv.includes("-g") || process.argv.includes("--global");
  if (global) {
    indexLines = [" * N/A - see global exports in 'types.js'"];
    typeLines = defLines;
  } else {
    indexLines = defLines;
    typeLines = [" * N/A - see reexports in 'index.js'"];
  }

  {
    let pkgTxt = await Fs.readFile("./package.json", "utf8");
    let pkg = JSON.parse(pkgTxt);
    let lines = [
      `"use strict";`,
      "// auto-generated by `jswt reexport`",
      "// DO NOT EDIT",
      "",
      `module.exports = require("./lib/${pkg.name}.js")`,
      "",
      "// these typedef reexports will be available to dependent packages",
      "/**",
    ].concat(indexLines, [" */", ""]);

    await Fs.readFile("./index.js", "utf8")
      .then(function (txt) {
        if (!txt.includes("generated by `jswt")) {
          /** @type {import('./jswt-init.js').MyError} */
          //@ts-ignore
          let err = new Error();
          err.problem = `'./index.js' exists and was not generated by 'jswt reexport'.`;
          err.solution = [`git mv index.js 'lib/${pkg.name}.js'`];
          throw err;
        }
      })
      .catch(function (err) {
        if ("ENOENT" === err.code) {
          return;
        }
        throw err;
      });
    await Fs.writeFile("./index.js", lines.join("\n"), "utf8");
    console.info(`Wrote './index.js' (exports './lib/${pkg.name}.js')`);
  }

  {
    let lines = [
      "// auto-generated by `jswt reexport`",
      "// DO NOT EDIT",
      "",
      "// global types (DO NOT include in `package.json.files`)",
      "",
      "/**",
    ].concat(typeLines, [" */", ""]);

    await Fs.writeFile("./types.js", lines.join("\n"), "utf8");
    if (global) {
      console.info(`Wrote GLOBAL exports to './types.js'`);
    } else {
      console.info(`Wrote './types.js' (stub file)`);
    }
  }
}

/** @type {import('./_walk.js').WalkFunc} */
async function shouldRead(err, pathname, dirent) {
  if (!dirent) {
    return false;
  }

  if (IGNORABLE.includes(dirent.name)) {
    return false;
  }

  if (IGNORABLE_PATTERNS.test(dirent.name)) {
    return false;
  }

  let ext = Path.extname(dirent.name);
  if (IGNORABLE_TYPES.includes(ext)) {
    return false;
  }

  // skip child directories that have their own package.json (such as git submodules)
  const isChildDir = "." !== pathname && dirent.isDirectory();
  if (isChildDir) {
    const submodulePkg = Path.join(pathname, "package.json");
    const isNormalDir = await Fs.access(submodulePkg).catch(Boolean);
    if (!isNormalDir) {
      return false;
    }
  }

  if (!dirent.isFile()) {
    return;
  }

  if (!LOADABLE.includes(Path.extname(dirent.name))) {
    //console.warn("# warn: skipping non-js file '%s'", filename);
    return;
  }

  return true;
}

main()
  .then(function () {
    process.exit(0);
  })
  .catch(function (err) {
    console.error(``);
    console.error(`Error:`);

    if (err.problem) {
      console.error(`    ${err.problem}`);
      console.error(`    ${err.stack}`);
      console.error(``);
      console.error(`Possible fix:`);

      let fix = err.solution.join(`\n    `);
      console.error(`    ${fix}`);
      throw err;
    }

    console.error(`${err.code}: ${err.message}`);
    console.error(err.stack);
  })
  .catch(function () {
    console.error(``);
    process.exit(1);
  });
